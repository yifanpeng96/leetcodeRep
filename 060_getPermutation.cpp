//60. 排列序列
//
//给出集合 [1,2,3,...,n]，其所有元素共有 n! 种排列。
//
//按大小顺序列出所有排列情况，并一一标记，当 n = 3 时, 所有排列如下：
//
//"123"
//"132"
//"213"
//"231"
//"312"
//"321"
//
//给定 n 和 k，返回第 k 个排列。

//Tips:
//以 x 为首个元素的排列共有 (n - 1)! 个, 所以第 k 个排列的首个元素是 [(k - 1) / (n - 1)!] + 1
//确定了首个元素a_1后, 以相似思路确定第二个元素a_2. 用 [1,n] \ a_1 表示包含 1 ~ n 中除去 a_1 以外元素的集合
//
//以 a_1 为首个元素, 以 [1,n] \ a_1 中最小的元素为第二个元素的排列共有 (n - 2)! 个
//以 a_1 为首个元素, 以 [1,n] \ a_1 中次小的元素为第二个元素的排列共有 (n - 2)! 个
//                                  ...
//以 a_1 为首个元素, 以 [1,n] \ a_1 中最大的元素为第二个元素的排列共有 (n - 2)! 个
//
//这些排列从编号 (a_1 - 1) * (n - 1)! 开始, 到 a_1 * (n - 1)! 结束, 总计 (n - 1)! 个
//因此第 k 个排列实际上对应着这其中的第 k' = (k - 1) % (n - 1)! + 1 个排列
//这样一来就把原问题转化成了一个完全相同但规模减少 1 的子问题

#include <iostream>
#include <vector>
using namespace std;

string getPermutation(int n, int k) {
    vector<int> factorial(n);
    factorial[0] = 1; //0 ~ n - 1 阶乘
    for (int i = 1; i < n; ++i) {
        factorial[i] = factorial[i - 1] * i; //factorial[n - 1] = (n - 1)!
    }

    /*
    k 需要先自减一 原因：
        不妨设分子为 k，那么得到的公式可能是这样的：
        ai = [k / (n - 1)!] + 1
        尝试使用以上公式计算 a1 :
        （1）当 k < (n - 1)!时，a1 = ⌊k / (n - 1)!⌋ + 1 = 1，正确
        （2）当 k = (n - 1)!时，a1 = ⌊k / (n - 1)!⌋ + 1 = 2，错误
        而使用 ai = [(k - 1) / (n - 1)!] + 1 却能正确处理这种情况
        即：只是简洁了数学公式的使用，如果不自减一的话，需要应对多种情况
    */
    --k;
    string ans;
    vector<int> valid(n + 1, 1); //0，1...n 排列标志集，标识在一整次寻找中哪个数已进排列中
    for (int i = 1; i <= n; ++i) { //排列中 依次取得的排列的数的个数 1个...n个
        //此公式可算出上面的数对应的从 1...n 中哪个数 order  | n - i 为了对应 factorial 下标,获取剩余个数排列种类总数
        int order = k / factorial[n - i] + 1;
        for (int j = 1; j <= n; ++j) { //依次寻找对应的数 从 1...n
            //找到一个数，若没有进入过结果排列集，减一，直至 order == 0 则表示找到该排列中的第 i 个数，修改标志集对应位置为已进入结果排序集
            order -= valid[j];
            if (!order) {
                ans += (j + '0');
                valid[j] = 0;
                break;
            }
        }
        k %= factorial[n - i]; //之后 k 对于已取得的数的排列位数取余，得到下一位需要的
    }
    return ans;
}

int main() {
	

	return 0;
}
